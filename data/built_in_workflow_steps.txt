Built-in Step TypesSuggest EditsStep types are a fundamental workflow building block. They define how each step is administered, validated, configured, and executed. Every workflow task originates from a step type. The types themselves often support extensibility (such as our Webhook step type) and derive most of their behavior through their configuration. There are a handful of built-in step types which can be useful for interacting with an external service via Workflow.Standard Step TypesWorkflow comes with many step types enabled by default that allow users to orchestrate action in Salsify. In this section, we cover some key standard step types that are useful for developers looking to integrate with Salsify via Workflow.External ConnectorsCall Webhook BotThe Call Webhook bot is a flexible connector providing the ability to connect Salsify to other systems and exchange information. This step type can make an HTTP request to an external endpoint. You can configure the HTTP headers to send API credentials if needed, and you can select and format which product data to send in the JSON request payload. Additionally, you can store the result of the request for use later in the workflow.With the Call Webhook bot you can:* Deliver messages from one or more bots to an endpoint - Each bot delivers a single payload to a single endpoint, but you can set up multiple bots in a workflow. If you want to deliver messages to two separate payloads from the same workflow, set up one bot per payload in your workflow. Note: see the Batch Bot if you'd like to make a batched web request.* Customize the message the bot delivers - You’ll choose which message the bot delivers. You can use variables to insert product identifiers (e.g., product name and ID) and property values (e.g., description or bullet points). You can also send static text. For example, you could send a message that says: “Product 123 - Widget was added to Wildflower”, where "123", "Widget", and "Wildflower" are all values that were inserted from what is stored in the product.* Pass the response to downstream tasks - Optionally, you can store the result of the webhook request, format it, and pass it to downstream tasks in the workflow to use the response data.??InfoThe Call Webhook step uses the default timeouts of the Ruby Net::Http client. It will time out if your request takes longer than one minute, and will retry the request with exponential backoff up to 5 times.Getting Started - Testing SetupThe first time you set up a Call Webhook bot, we recommend setting up a simplified test workflow to make sure it behaves the way you want before adding it to a larger workflow.This will allow you to quickly iterate on the message you deliver, test functionality, and avoid confusion with test messages.To set up a test Webhook bot:1. In Salsify, create a new test workflow. Be sure to name it clearly so that team members know it’s just for testing.o Your test workflow can be as simple as a manual trigger connected to a Salsibot.o Feel free to add additional step(s) if you want to test the bot functionality with other steps.2. Add a webhook bot to your workflow, then save the workflow.3. Test the webhook. You may consider using a free webhook testing service like Beeceptor, which sets up a temporary location to catch your webhooks. This allows you to test the webhook and refine the content of your messages before they’re pushed into a live system. If you use a temporary testing service, you can update the URL in the production bot with the production webhook URL later.4. When you’re finished testing, keep your test workflow open, and open your production workflow in another Salsify tab.5. Add your Webhook bot to the production workflow and copy the settings from the test workflow.Configuration InstructionsThe table below defines each of the configuration fields for the Call Webhook bot.FieldDescriptionWorkflow Step NameThis is the name of the step that will appear on the step tile on the Workflow Builder. It is best practice to give this a descriptive name - we recommend including the endpoint and a brief summary of the action it performs.Bot OwnerEach bot must have an owner, which will appear in activity logs. The bot has the same permissions as the owner. As a best practice, consider creating an “automated tasks” user for automations to run through. You can also set the bot owner as yourself.DomainEnter the webhook URL for the service that will be receiving the request.Configure Request HeadersTo add custom headers to the webhook, toggle on Configure Request Headers. Once this is on, you can configure the headers to send with the request in the "Headers" field.ActionChoose the HTTP request method the webhook should use. In most cases, you’ll use POST (add), PUT (update) or DELETE (remove).PayloadThe message you’re sending to the receiving service. The message must be JSON-formatted key-value pairs. The keys do not have to match anything in Salsify; they are for your receiving service to identify the data being sent. You can use variables in the payload to return information from property values in Salsify.Store ResultTo store the response data and pass it to downstream tasks, toggle Store Result. Once this is on, you can define the variable that the data should be stored in using the "Store Result At" field. You can add simple JavaScript in the "Transform Result" field to manipulate the request response using the result object. See below for a more detailed example.To store the response data in a property on the entity itself, add a Product Edit, Record Edit, or Digital Asset Edit step. You can define the property the data will be assigned to and reference the stored result from previous steps in the flow.Example ConfigurationLet's say you are kicking off a project in an external tool called MyTool. Add a "Call Webhook" bot to your workflow, and set the Workflow Step Name to "Create MyTool Project". Assign yourself as the Bot Owner and enter the domain https://salsify.mytool.com/project/create.The MyTool service requires that you send request headers, so toggle "Configure Request Headers" and add content to the Headers field following the MyTool API guidelines. In order to use a secret for the authorization token, you should press the "Add Secret" button.The secret you create should look something like:JSON{  "X-User-Id": "salsifyperson",  "Content-Type": "application/json",  "Authorization": "Bearer {{ 'test_secret' | secret_value }}"}Set the action to POST and add the following data to the Payload field, which will tell MyTool what to name your new project:JSON{  "project_name": "{{entity.external_id}} Project "}Since we want to store this project name in Salsify (and set that property value in a downstream task), we want to toggle on "Store Result" and set "Store Result At" to mytool_project_id (we chose this variable name so we would remember what it is later). We already know that the response from the MyTool API is going to come in the following form:JSON{  "data": {    "id": "adsfajsf2ef"  }}To make sure that we pull the correct data from the request response to store in our mytool_project_id field, we set the Transform Result field as follows:JavaScriptresult.data.id;Downstream tasks can now reference this data in any fields that allow variables by referencing {{ context.mytool_project_id }}.JavaScript ProgramThis step type can execute a JavaScript program either written inline or from an external source. The program is limited to a 10 second runtime. In addition to supporting standard JavaScript methods and objects, we provide some Salsify-specific tools that are accessible from this bot. See Templating with JavaScript for more information.Extended TimeoutIf the JavaScript program requires more than 10 seconds of runtime, toggle the Extended Timeout option on the Javascript Program step. When the Extended Timeout option is enabled the JavaScript program's runtime is extended to 60 seconds.Poll BotThis step type allows you to pause the workflow and wait for a condition to become true. This can be useful for waiting for an asynchronous operation in an external service to complete. The configuration panel for this bot has some documentation, but here is an example:JavaScript// Get statusconst url = 'https://beeceptor.com/'+context.job_id;const method = 'post';const payload = { ... };const headers = { ... };const response = web_request(url, method, payload, headers);// Resolveif (response.data.status === 'completed') {  resolve(response.data, {    complete_task: true,    context_key: 'my_operation_result'  });// context.my_operation_result used in downstream tasks will have the response.data stored in this step}In this example, a prior JavaScript Program bot or a Call Webhook bot was used with the Store Result functionality to store an asynchronous job ID from a third-party service as job_id. The Poll Bot then checks the status of the job by making a call to a separate API with the stored job_id. In a scenario where the Poll Bot is used for polling an asynchronous API call made to a third-party service, it comes after a Call Webhook or a Javascript Program bot in the workflow. To prevent overloading the third-party service, the Poll Bot can be configured with an interval time.The Poll Bot supports a special additional set of template methods, which are documented hereReview ChangesThis step type allows you to set up a review process for draft product data created earlier in the same workflow or ingested via Salsify import using the experimental import trigger.??Notes* The Review Changes step generates a diff view on the product properties only if there is a change in the draft property value from the existing property value on the product.Usage InstructionsReview a Product ImportFollow the instructions for configuring and setting up an Import Trigger in your workflow and add a Review Changes step.Whenever there are product updates to review, kick off a new import either manually or via FTP using the same import channel. Once the import is complete, the workflow will be triggered and tasks will be created for products included in the import, and any new or modified properties.Review Proposed Changes from a Third PartyWhen your workflow involves using the JavaScript Program or Call Webhook step type to request data from a third party API, you can use the Review Changes step type to prompt a user to review any changes before committing them to the product record. Configure the web request step to create a draft of the proposed changes (as described below), and pass the draft (or changeset) identifier to the downstream Review Changes step type. The assigned user will be prompted to review the updates and may accept or reject the proposed changes.Example: JavaScript ProgramIn this example, the Review Changes step is preceded by a JavaScript Program step. The JavaScript Program step includes a call to the changeset_save template method, and the output of this method (the changeset identifier) is stored in the changeset_id field so that it will be accessible to the Review Changes step as context.changeset_id.Example: Call WebhookIn this example, the Review Changes step is preceded by a Call Webhook step. The Call Webhook step sends a request to an external API to fetch new property values to apply to the product. The "Transform Result" field parses the response from the external API, calls the changeset_save template method, and stores the changeset ID in the changeset_id field so that it will be accessible to the Review Changes step as context.changeset_id.Configuration InstructionsThe Review Changes step type configuration expects a changeset_id set on the flow context (either via importing proposed changes or in the previous step). The step type then needs a valid assignee and a title.  Workflow ControlsConditional Branch BotThis step type allows you to add conditional routing to your workflow. You can route your workflow down different paths based on the result of evaluating a Liquid or JavaScript expression. For example, you can:* Route based on an entity's value for a property (e.g., category)* Route based on the result of a "Call Webhook" stepFirst, configure the potential paths your workflow can take by defining resolutions for the step under the "Resolutions" headers. Take note of how you name your resolutions as you will need to reference the names in your expression. Also note that every entity passing through the workflow must satisfy one of the resolution criteria or the Conditional Branch Bot will be stuck in a Waiting status, blocking the workflow from moving forward.Once you have defined the potential resolutions, write your conditional logic in the "Branch Condition" field. The result of your expression should be the name of one of the resolutions (must be exact spelling and case).Picklist properties are accessed differently than typical string properties. Picklist properties return an object and must be accessed using an object attribute such as .external_id.ExamplesString Properties:JavaScript!js;const category = property_value(entity, "Category");if (category === "Pants") {  ("Resolution A");} else if (category === "Shoes") {  ("Resolution B");} else {  ("Unknown");}Picklist Properties:JavaScript!js;const category = property_value(entity, "Category").external_id;if (category === "Pants") {  ("Resolution A");} else if (category === "Shoes") {  ("Resolution B");} else {  ("Unknown");}Multiple Picklist Properties in a single resolution:JavaScript!js;const category = property_value(entity, "Category", (index = 0)).external_id;if (category === "Short Sleeve Shirt" || category === "Long Sleeve Shirt") {  ("Resolution A");} else {  ("Resolution B");}JavaScript REPLThis step type allows you to pause the workflow and enter a JavaScript REPL from the Task View to experiment with JavaScript templates. All available variables and template methods (including the advanced template methods) described in the templating guide are available. The variables and template methods are also provided for convenience from within any active JavaScript REPL tasks under the "Template Variables" and "Available Template Methods" headers.When a JavaScript REPL task is created, it initially appears empty except for the "Template Variables" and "Available Template Methods" sections. To test a JavaScript template, enter your JavaScript into the "Javascript" section. For example, you might reference the "Template Variables" section to note that there is a flow_template object with a name key and a context.entity nested object with a name key available, and write:JavaScript1 + 2 + " - " + flow_template.name + " - " + context.entity.name;To evaluate the template, click "Select Resolution", select "Evaluate Template", and click "Resolve". This task will complete, and you will be able to see the result in the Task View (More > Tasks) with other completed tasks. In this case, the completed task in the Task View would show the input JavaScript above and a "Template Result" value like: 3 - Test REPL Workflow - Product XY.At that point, a new manual JavaScript REPL task will be created. When you select the new task from the Task View, you'll see the previous JavaScript and "Template Result" value from the completed task under "Previous Template" and "Previous Template Result". You can then repeat the process: update the JavaScript, resolve the task to evaluate the templated JavaScript, and open the completed task to view the new template result. Once you are satisfied with the template output, use the JavaScript template you created in a task on the Workflow Builder by copying it to a templatable step configuration field prefaced by !js. For example, adding !js (1 + 2) + " - " + flow_template.name + " - " + context.entity.name to a templatable field in a step configuration would give the same result as above: 3 - Test REPL Workflow - Product XY. This could be used in a task title or description field to dynamically set the task data.Once you're done testing with the REPL, select the "Continue" resolution to break the REPL loop and move on to the next step of the workflow.Note: Although all Advanced Template Methods are available in the REPL task, they are still only available in supported task types. Templatable fields such as the task title and task description do not support these methods. As an example, web_request('https://test.test', 'GET') would work in the "JavaScript REPL" or "JavaScript Program" task types, but !js web_request('https://test.test', 'GET') wouldn't work in a task description because web_request is an advanced method.The JavaScript REPL section of the Workflow Troubleshooting page has more information about using the JavaScript REPL bot to debug a workflow's configuration.Experimental Step Types??WarningSalsify reserves the right to reject any Workflow template that has been submitted if the template contains any of the following experimental step types.These step types are not enabled by default in customer organizations. Salsify may enable these step types in partner organizations to help developers explore new potential functionality.Use these step types with caution; they are subject to change in future releases.To learn more about the step types described in this section and to how to enable them in your Salsify organization, please Contact Us.Batch BotThis step type allows you to batch data across multiple workflow instances (or even workflows) and then execute a JavaScript program with the batched data. For example, you could batch a set of product IDs to make an API call to an external API that expects multiple product IDs. Batch Bot steps run asynchronously, so the workflow will continue while the batching occurs.Key Use Case: Aggregating products across workflow runs to send data to a third party in a single requestRecommended workaround: The batch bot is experimental and cannot be used by customers. There is no official substitute for the batch bot today. However, there may workarounds that satisfy your business needs. If you need to batch data across multiple products, please consult with Salsify so that we can evaluate whether there is a good workaround for you.??NotesAs called out in the sections below, if you are batching data across multiple workflows (and not just instances of the same workflow) you will need to add this bot to each workflow and ensure the configuration is consistent. In particular, the Batch Key and Batch Handler should execute to the same value, and if the Batching Type configuration differs across steps, Workflow will assume the earliest flush time should be used.Batch KeyThis field determines what data will be grouped together. If you need to make this key dynamic, you can use the standard templating features. This key works across workflows, so you could batch data from multiple independent workflows.Note: the Bot Owner is implicitly part of the batch key, so ensure you have the same Bot Owner defined across all steps you want to batch.DataThis field determines an individual item of data that will be available in the batch handler as an array. For example:JSON{  "product_id": "{{ entity.id }}"}Batch HandlerThis field is where you write the JavaScript code to run when the batch flushes. See Advanced Template Methods for information on the available methods. Only the data supplied in the data field above will be available to the batch handler. In particular, the usual data available to tasks will not be accessible to this code at runtime unless it's explicitly been passed to the batch handler via the data field above.Note: the Batch Handler configuration should be identical across all instances in the batch.JavaScriptconst product_ids = data.map(i => i.product_id);web_request("myapi.com", "post", { data: product_ids });Batching TypeWe support two modes of batching: "starvation + cooldown" and "run at".Starvation + CooldownWith this batching type, whenever a new item is added to the batch, Workflow resets the timer to the "Cooldown" interval. When that timer hits zero, we flush the batch. If items are constantly being added to the batch and therefore resetting the timer, Workflow will force the batch to flush when either the "Max Batch Size" or "Starvation" interval is reached.Run AtWith the "Run At" batching type, Workflow will flush the batch at the "Run At" time. This field expects a timestamp provided in ISO 8601 format.Note: the "Run At" field is templatable, but the input that you use for each step in the same batch should evaluate to the same value. If not, Workflow will use the earliest time specified in the batch as the "Run At" time.Waiting for the batch to completeBy default, workflows with the batch task in them will continue execution immediately without waiting for the batch of work to execute. In some situations this may be desirable, but in others, such as when downstream tasks rely on the work executed in the the batch task to function properly, this behavior isn't ideal.When using the "Starvation + Cooldown" mode, an additional "Wait for batch to complete before continuing?" option is exposed. With this option enabled, the batch task will remain in the "waiting" status until the batch finishes successfully or fails. If it fails, information about the failure will be present in the task description.Remote Automated TaskThis step type provides a skeleton that allows you to define a custom automated task in JavaScript. You are able to load the task's source from a remote location so you can share the task between workflows and update it in a single location.ExampleJavaScript// We require you implement `build_task` to return the definition of the task.function build_task() {  return {    // Use functions for lazy evaluation.    name: () => `Task for ${context.entity.external_id}`,    description: "My custom task",    task_data,    view_config: {      completed: completed_view    },    status_callbacks: {      before_completed    }  };}function completed_view() {  return {    ui: {      $text: `Hello from ${entity.external_id}`    }  };}function before_completed() {  return [    {      operation: "web_request",      params: {        url: "myurl.com",        method: "post",        payload: { test: "data" }      }    }  ];}Available Fields* name (String, required): The task name* description (String): The task description* skip_condition (Boolean): Return true to skip this task* task_data (Object): Mutable state for the task* view_config.{waiting|completed|failed} (Object): UI to show for the tasks' state* status_callbacks.{before_waiting|before_completed} (Array): Operations to run at various points in the task's lifecycleRemote TaskThis step provides a skeleton that allows you to define a custom manual task in JavaScript. We allow you to load the task's source from a remote location so you can share the task between workflows and update it in a single location.Key Use Case: Define the structure and actions taken in the task flexibly from the task configuration; most configurable and flexible step type.Recommended workaround: The remote task is experimental and cannot be used by customers. If you need to substitute the remote task for something that has been officially released, please refer to other step types (JavaScript Bot, Webhook Bot.)ExampleJavaScript// We require you implement `build_task` to return the definition of the task.function build_task() {  return {    // Use functions for lazy evaluation.    name: () => `Task for ${context.entity.external_id}`,    assignee_id: () => user_system_id("user-a@demo.com"),    assignee_type: "user",    description: "My custom task",    task_data,    view_config: {      active: active_view    },    status_callbacks: {      before_completed    }  };}function active_view() {  return {    ui: {      $text: `Hello from ${entity.external_id}`    }  };}function before_completed() {  return [    {      operation: "web_request",      params: {        url: "myurl.com",        method: "post",        payload: { test: "data" }      }    }  ];}Available Fields* name (String, required): The task name* description (String): The task description* task_path (String): Path in the app to navigate to when the task is opened (e.g., /products/${entity.id})* thumbnail_url (String): (e.g., entity.thumbnail_url)* assignee_id (SalsifyUuid, required): The system ID of the assignee* assignee_type ('user' | 'group' | 'user_group')* skip_condition (Boolean): Return true to skip this task* task_data (Object): Mutable state for the task* view_config.{waiting|completed|failed} (Object): UI to show for the task's state* status_callbacks.{before_completed} (Array): Operations to run at various points in the task's lifecycle* task_resolutions (Array): Array of available resolutions for the tasko id (String, required): The ID of the resolutiono text (String, required): The text the user seeso style: ('good' | 'danger'): Style for the resolution buttono confirm: (Exclaim): Confirmation UI to show the user