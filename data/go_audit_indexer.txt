Go Audit Indexer DesignNotesHighlevelAt a high level, the audit indexer consumes messages from a variety of topics and indexes them into Elasticsearch. After polling a group of kafka records, the audit indexer batches the records by partition id and pushes the batch to a dedicated Go channel for each partition id. Each partition’s Go channel is provided a dedicated worker, or go routine, which will work off the channel. A worker picks up an available batch of records from their channel, serializes each record to its equivalent Elasticsearch document representation and pushes it onto an internal channel held by the BulkIndexer. Before picking up the next batch, the worker waits for its current batch to complete indexing by listening on a special channel. This special channel will be written to by the BulkIndexer once indexing is complete. Every time a document is indexed, a callback function is invoked which decrements the number of documents still needing to be indexed in the batch. Once that number hits zero, the callback inserts a message onto this special channel as a symbol that the BulkIndexer has completed indexing the batch. The document serializing worker can then commit offsets and pickup the next available batch.Handling RebalancesSince we run multiple consumers (currently 2) there’s a strong chance our consumers will need to rebalance partition assignments (especially during deploys too). The kafka client exposes callbacks we can define for when partitions are assigned or lost. When a partition is assigned, we lock the audit indexer’s worker table (the table which maps a [topic, partition id] pair to a worker) and initialize a worker to handle the new partition. When a partition is lost, we lock the table and remove the worker. In the worker's main loop, we continually check on a dedicated quit channel. When removing the worker, we emit a message to this channel causing the worker to terminate.